# Copyright 2026 Dell Inc. or its subsidiaries. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Consolidated NFS-based implementation for input directory and configuration management."""

import logging
import os
from pathlib import Path
from typing import Optional

import yaml

from common.config import load_config
from core.build_image.repositories import (
    BuildStreamConfigRepository,
    BuildImageInventoryRepository,
)
from core.build_image.value_objects import InventoryHost

logger = logging.getLogger(__name__)

# Load configuration to get base path
try:
    local_config = load_config()
    DEFAULT_BUILD_STREAM_BASE = Path(local_config.file_store.base_path)
except (FileNotFoundError, AttributeError):
    # Fallback to default path if config is not available
    DEFAULT_BUILD_STREAM_BASE = Path("/opt/omnia/build_stream")

DEFAULT_PLAYBOOK_INPUT_DIR = "/opt/omnia/input/project_default/"


def _read_project_name(default_file_path: str = "/opt/omnia/input/default.yml") -> str:
    """Read project_name from default.yml.

    Args:
        default_file_path: Path to default.yml file.

    Returns:
        Project name (e.g., "project_default"). Returns 'project_default' fallback on any error.
    """
    default_path = Path(default_file_path)
    if not default_path.exists():
        return "project_default"

    try:
        with open(default_path, "r", encoding="utf-8") as f:
            config = yaml.safe_load(f)
        if not config or "project_name" not in config:
            return "project_default"
        return str(config["project_name"])
    except yaml.YAMLError:
        return "project_default"
    except Exception:
        return "project_default"


class NfsInputRepository(BuildStreamConfigRepository, BuildImageInventoryRepository):
    """Consolidated NFS repository for input directory and configuration management.

    This repository combines functionality for:
    - Input directory path management
    - Configuration file reading
    - Inventory file creation

    Manages paths for input files generated by the GenerateInputFiles API,
    reads build stream configuration, and creates inventory files for aarch64 builds.
    """

    def __init__(
        self,
        config_file_path: Optional[str] = None,
        default_file_path: str = "/opt/omnia/input/default.yml",
        playbook_input_dir: str = DEFAULT_PLAYBOOK_INPUT_DIR,
        build_stream_base: str = DEFAULT_BUILD_STREAM_BASE,
        inventory_base_dir: str = "/opt/omnia/build_stream_inv",
    ):
        """Initialize repository with consolidated paths.

        Args:
            config_file_path: Full path to build_stream_config.yml. If None, constructed
                             using project_name from default.yml.
            default_file_path: Path to default.yml to read project_name.
            playbook_input_dir: Destination path expected by playbook.
            build_stream_base: Base path for build stream job data.
            inventory_base_dir: Base directory for inventory files.
        """
        # Initialize configuration paths
        if config_file_path is None:
            project_name = _read_project_name(default_file_path)
            config_file_path = f"/opt/omnia/input/{project_name}/build_stream_config.yml"
        self._config_file_path = Path(config_file_path)

        # Initialize input directory paths
        self._playbook_input_dir = Path(playbook_input_dir)
        self._build_stream_base = Path(build_stream_base)

        # Initialize inventory directory paths
        self._inventory_base_dir = Path(inventory_base_dir)

    # === Configuration Methods ===

    def get_aarch64_inv_host(self, job_id: str) -> Optional[InventoryHost]:
        """Retrieve aarch64 inventory host IP from build_stream_config.yml.

        Args:
            job_id: Job identifier.

        Returns:
            Inventory host IP address or None if not configured.

        Raises:
            ConfigurationError: If config file is invalid or inaccessible.
        """
        config_path = self._config_file_path

        if not config_path.exists():
            logger.warning(
                "build_stream_config.yml not found at %s (job %s)",
                job_id,
                config_path,
            )
            return None

        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config = yaml.safe_load(f)
                
            if not config:
                logger.warning("Empty build_stream_config.yml for job %s", job_id)
                return None
                
            inventory_host = config.get("aarch64_inventory_host_ip")
            if inventory_host:
                logger.info(
                    "Retrieved inventory_host for job %s: %s",
                    job_id,
                    inventory_host,
                )
                return InventoryHost(str(inventory_host))
            
            logger.info("No aarch64_inventory_host_ip configured for job %s", job_id)
            return None
            
        except yaml.YAMLError as exc:
            logger.error(
                "Failed to parse build_stream_config.yml for job %s: %s",
                job_id,
                exc,
            )
            return None
        except Exception as exc:
            logger.error(
                "Unexpected error reading build_stream_config.yml for job %s: %s",
                job_id,
                exc,
            )
            return None

    # === Inventory File Methods ===

    def create_inventory_file(self, inventory_host: InventoryHost, job_id: str) -> Path:
        """Create an inventory file for aarch64 builds.

        Args:
            inventory_host: The inventory host IP address.
            job_id: Job identifier for tracking.

        Returns:
            Path to the created inventory file.

        Raises:
            IOError: If inventory file cannot be created.
        """
        try:
            # Create inventory directory if it doesn't exist
            inventory_dir = self._inventory_base_dir / job_id
            inventory_dir.mkdir(parents=True, exist_ok=True)

            # Create inventory file path
            inventory_file = inventory_dir / "inv"

            # Create inventory content
            inventory_content = f"[admin_aarch64]\n{inventory_host.value}\n"

            # Write inventory file
            with open(inventory_file, "w", encoding="utf-8") as f:
                f.write(inventory_content)

            logger.info(
                "Created inventory file for job %s at %s with host %s",
                job_id,
                inventory_file,
                inventory_host.value,
            )

            return inventory_file

        except (OSError, IOError) as exc:
            logger.error(
                "Failed to create inventory file for job %s: %s",
                job_id,
                exc,
            )
            raise IOError(f"Cannot create inventory file for job {job_id}: {exc}") from exc

    # === Input Directory Management Methods ===

    def get_source_input_repository_path(self, job_id: str) -> Path:
        """Get source input directory path for a job.

        Args:
            job_id: Job identifier.

        Returns:
            Path like /opt/omnia/build_stream/{job_id}/input/
        """
        return self._build_stream_base / job_id / "input"

    def get_destination_input_repository_path(self) -> Path:
        """Get destination input directory path expected by playbook.

        Returns:
            Path like /opt/omnia/input/project_default/
        """
        return self._playbook_input_dir

    def validate_input_directory(self, path: Path) -> bool:
        """Validate that input directory exists and contains required files.

        Args:
            path: Path to the input directory to validate.

        Returns:
            True if directory is valid and contains at least one file.
        """
        if not path.is_dir():
            logger.warning("Input directory does not exist: %s", path)
            return False

        has_files = any(path.iterdir())
        if not has_files:
            logger.warning("Input directory is empty: %s", path)
            return False

        return True
